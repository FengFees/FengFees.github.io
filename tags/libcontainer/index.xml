<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>libcontainer on 浙大SEL实验室</title>
    <link>https://fengfees.github.io/tags/libcontainer/</link>
    <description>Recent content in libcontainer on 浙大SEL实验室</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 03 Jun 2015 13:29:26 +0000</lastBuildDate>
    
	<atom:link href="https://fengfees.github.io/tags/libcontainer/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Docker背后的容器管理——libcontainer深度解析</title>
      <link>https://fengfees.github.io/blog/docker%E8%83%8C%E5%90%8E%E7%9A%84%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86-libcontainer%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 03 Jun 2015 13:29:26 +0000</pubDate>
      
      <guid>https://fengfees.github.io/blog/docker%E8%83%8C%E5%90%8E%E7%9A%84%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86-libcontainer%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid>
      <description>libcontainer 是Docker中用于容器管理的包，它基于Go语言实现，通过管理namespaces、cgroups、capabilities以及文件系统来进行容器控制。你可以使用libcontainer创建容器，并对容器进行生命周期管理。
 容器是一个可管理的执行环境，与主机系统共享内核，可与系统中的其他容器进行隔离。
 在2013年Docker刚发布的时候，它是一款基于LXC的开源容器管理引擎。把LXC复杂的容器创建与使用方式简化为Docker自己的一套命令体系。随着Docker的不断发展，它开始有了更为远大的目标，那就是反向定义容器的实现标准，将底层实现都抽象化到libcontainer的接口。这就意味着，底层容器的实现方式变成了一种可变的方案，无论是使用namespace、cgroups技术抑或是使用systemd等其他方案，只要实现了libcontainer定义的一组接口，Docker都可以运行。这也为Docker实现全面的跨平台带来了可能。
1. libcontainer 特性 目前版本的libcontainer，功能实现上涵盖了包括namespaces使用、cgroups管理、Rootfs的配置启动、默认的Linux capability权限集、以及进程运行的环境变量配置。内核版本最低要求为2.6，最好是3.8，这与内核对namespace的支持有关。 目前除user namespace不完全支持以外，其他五个namespace都是默认开启的，通过clone系统调用进行创建。
1.1 建立文件系统 文件系统方面，容器运行需要rootfs。所有容器中要执行的指令，都需要包含在rootfs（在Docker中指令包含在其上叠加的镜像层也可以执行）所有挂载在容器销毁时都会被卸载，因为mount namespace会在容器销毁时一同消失。为了容器可以正常执行命令，以下文件系统必须在容器运行时挂载到rootfs中。
路径
类型
参数
权限及数据
/proc
proc
MS_NOEXEC,MS_NOSUID,MS_NODEV
/dev
tmpfs
MS_NOEXEC,MS_STRICTATIME
mode=755
/dev/shm
shm
MS_NOEXEC,MS_NOSUID,MS_NODEV
mode=1777,size=65536k
/dev/mqueue
mqueue
MS_NOEXEC,MS_NOSUID,MS_NODEV
/dev/pts
devpts
MS_NOEXEC,MS_NOSUID
newinstance,ptmxmode=0666,mode=620,gid5
/sys
sysfs
MS_NOEXEC,MS_NOSUID,MS_NODEV,MS_RDONLY
当容器的文件系统刚挂载完毕时，/dev文件系统会被一系列设备节点所填充，所以rootfs不应该管理/dev文件系统下的设备节点，libcontainer会负责处理并正确启动这些设备。设备及其权限模式如下。
路径
模式
权限
/dev/null
0666
rwm
/dev/zero
0666
rwm
/dev/full
0666
rwm
/dev/tty
0666
rwm
/dev/random
0666
rwm
/dev/urandom
0666
rwm
/dev/fuse
0666
rwm
容器支持伪终端TTY，当用户使用时，就会建立/dev/console设备。其他终端支持设备，如/dev/ptmx则是宿主机的/dev/ptmx 链接。容器中指向宿主机 /dev/null的IO也会被重定向到容器内的 /dev/null设备。当/proc挂载完成后，/dev/中与IO相关的链接也会建立，如下表。</description>
    </item>
    
  </channel>
</rss>